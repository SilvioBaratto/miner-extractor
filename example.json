{
  "content": "December 2022  \n\n# Forward engineering methods in the context of BIRD  \n\n# Content  \n\n0. Version control 2   \n1. Introduction 2   \n1.1 Remark on normalisation & denormalisation 3   \n2. Forward engineering methods 3   \n2.1 General considerations regarding forward engineering 4   \n2.1.1 Treatment of optionality for enumerated and non-enumerated attributes / columns 4   \n2.1.2 Conserving referential integrity (via validation rules & Null Explanatory Values (NEVs)) 4   \n2.2 Merging entity types into tables 7   \n2.2.1 Merging entity types into a supertype / subtype 7   \n2.2.2 Merging entity types connected via relationship types 14   \n2.2.3 Merging tables with equal surrogate keys 21  \n\n# 0. Version control  \n\n<html><body><table><tr><td>Version</td><td>Date</td><td>Comments</td></tr><tr><td>1.0</td><td>08/11/2021</td><td>Initial draft</td></tr><tr><td>1.1</td><td>16/12/2022 (LDM/IL)review.</td><td>Incorporationofcommentsandsuggestionsforimprovement provided by members of the Work Stream on Prototyping (formerlyknown as Work Stream on Testing) and of the temporary BIRD subgroup on logical data model and input layer</td></tr></table></body></html>  \n\n# 1. Introduction  \n\nThe information that is relevant for fulfilling the reporting requirements covered by the BIRD documentation is described in the BIRD Logical Data Model (LDM). This LDM is a highly normalised model that describes the logic of the business domain (i.e., the information that is relevant for fulfilling the reporting requirements), it does not take into account any implementation specific considerations.  \n\nThe BIRD Input Layer (IL) is intended to act as an implementation model based on the IL design principles. This IL is derived from the LDM via so called forward engineering methods which we define as a combination of denormalisation and additional (validation) rules to ensure “semantic equivalence” between the LDM and the IL. This document’s purpose is to describe these forward engineering methods, their behaviour and implications1. It also tries to describe the validation rules2 that are necessary to ensure that the data stored in the IL is consistent with the definition of the data structures in the LDM.  \n\nTo support the reader in distinguishing between logical and technical model artefacts we will use the terms entity type and attribute when referring to the LDM and table and column for the implementation model (e.g. IL). We will use the term domain when referring to both models.  \n\nPlease note that the examples given in this document were adapted for educational purpose and do not represent the exact state of the LDM or IL.  \n\n# 1.1 Remark on normalisation & denormalisation  \n\nBefore describing the forward engineering methods which is a denormalisation process, we believe it important to define what we mean by denormalisation because “for a practice that’s so widely advocated, there seems to be considerable confusion over what denormalisation actually consists of.”3. Fully aligned with the author of this quote we define denormalisation as the inverse of normalisation and therefore the process to decrease a data structure’s normal form to a lower normal form, e.g., from 3rd normal form to 2nd normal form. In order to avoid losing information the documentation of validation rules for the new data structure resulting from denormalisation is required.  \n\nAs regards the question when a model is sufficiently denormalised we would like to underline that “With normalisation, where there are clear logical reasons for continuing the process until we reach the highest possible normal form. Do we then conclude that with denormalisation we should proceed until we reach the lowest possible normal form? Surely not; yet there are no logical criteria for deciding exactly where the process should stop. In choosing to denormalise, in other words, we’ve backed from a position that does at least have some solid science and logical theory behind it, and replaced it by one that’s purely pragmatic in nature…”4.  \n\n# 2. Forward engineering methods  \n\nThis section describes the different forward engineering methods. Each method is introduced by a description of the operation itself, i.e., what operation is to-be-applied onto the entity types of the LDM to forward engineer tables of the IL, an example and an analysis of the implied consequences for applying this forward engineering method. The first subsection of this chapter describes general aspects about forward engineering which are relevant for all following sections.  \n\nPlease note that we have amended the existing LDM by adding additional attributes or changing the optionality of attributes to cover relevant cases regarding forward engineering from a conceptual perspective. Wherever there were adjustments made to the LDM we will highlight it in the respective section or example accordingly.  \n\n# 2.1.1 Treatment of optionality for enumerated and non-enumerated attributes / columns  \n\nFirstly, we would like to highlight the different treatment of enumerated and non-enumerated attributes in the LDM and columns in the IL with respect to their representation of optionality, i.e., if these attributes / columns are considered as optional or not.  \n\nEnumerated attributes / columns are attributes / columns where only a defined set of values is allowed, an example would be the Address country which allows only countries listed in ISO 3166. Non-enumerated attributes / columns on the other hand are attributes / columns where the allowed values are not specified via a set of specific values but defined more broadly, e.g., the Balance sheet total which may be any numeric value.  \n\nOptionality of an attribute / column specifies if this attribute / column is optional or mandatory.  \n\nFor non-enumerated attributes / columns optionality is specified on the attribute / column itself, i.e. the attribute / column in the entity type / table is defined to be optional or mandatory. For example, mandatory attributes in the LDM are indicated via a red star next to the attribute itself as illustrated in the following picture.  \n\n![](/app/media/extracted/images/d6233c40de97a0dc6bcfae8b196725a16d97df9a9d97d814a34218e8d21bf9ad.jpg)  \nFigure 1: Entity Organisation having mandatory (red star) and non-mandatory Attributes  \n\nFor enumerated attributes / column optionality is specified differently. It is specified via a specific value, i.e. Not applicable, and enumerated attributes / columns are always defined as mandatory (always have a red star next to the attribute itself). Consequently, if the allowed values for an enumerated attribute / column comprises the value Not applicable this attribute / column is defined as optional. Conversely, if the allowed values do not comprise the value Not applicable, this attribute / column is defined to be mandatory.  \n\n# 2.1.2 Conserving referential integrity (via validation rules & Null Explanatory Values (NEVs))  \n\nThe second aspect that we would like to highlight concerns the conservation of referential integrity, which may be formulated as: the forward engineering methods that are applied to the LDM should conserve the rules which are specified in the LDM itself.  \n\nAn example of such a rule is the attribute International organisation code which is only applicable to International organisations, like the International Monetary Fund or the European Central Bank. For all other types of Organisations, like Credit institutions or Non-financial institutions the attribute International organisation code does not exist. If we put different types of Organisations into one table which comprises the column International organisation code we need to ensure that only for Organisations which are International organisations this column is populated with an allowed value, while for Organisations which are not International organisations this column must take the value Not applicable. If we wouldn’t conserve this referential integrity constraint the result IL would allow to represent Organisations which are not International organisations having an International organisation code, which is clearly a data quality issue which may result in incorrect aggregation and therefore incorrect output figures.  \n\n2.1.2.1. Example The following example will give the reader an overview of the type of validations that are required to ensure referential integrity. It is also the basis for the following section dedicated to Null Explanatory Values (NEVs) & validation rules.   \n\n\n<html><body><table><tr><td colspan=\"3\">Organisation</td></tr><tr><td>Legal person identifier</td><td>Organisationname</td><td>Balancesheettotal</td></tr><tr><td>mandatory</td><td>mandatory</td><td>optional</td></tr><tr><td>{String}</td><td>{String}</td><td>{lnteger}</td></tr><tr><td>Apple Inc.</td><td>AppleInc.</td><td>57,000,000,000</td></tr><tr><td>GruneErde</td><td>GruneErde</td><td>NULL</td></tr><tr><td>GoldmanSachs Group,Inc.</td><td>GoldmanSachsGroup, Inc.</td><td>12,000,000,000,000</td></tr><tr><td>Othercompany</td><td>Othercompany</td><td>NULL</td></tr><tr><td></td><td></td><td></td></tr></table></body></html>  \n\nLet’s assume we have two entity types that we want to merge into one table holding the following data:  \n\nFigure 2: Content of the entity type Organisation   \nFigure 3: Content of the entity type Natural person   \n\n\n<html><body><table><tr><td colspan=\"3\">Naturalperson</td></tr><tr><td>Legalperson identifier</td><td>Firstname</td><td>Lastname</td></tr><tr><td>mandatory</td><td>mandatory</td><td>mandatory</td></tr><tr><td>{String}</td><td>{String}</td><td>{String}</td></tr><tr><td>MarieCurie</td><td>Marie</td><td>Curie</td></tr><tr><td>AlbertEinstein</td><td>Albert</td><td>Einstein</td></tr><tr><td>BernhardRiemann</td><td>Bernhard</td><td>Riemann</td></tr><tr><td></td><td></td><td></td></tr></table></body></html>  \n\nMerging this data into one data result in the following Table:  \n\n<html><body><table><tr><td colspan=\"6\">Organisation&Naturalpersontable</td></tr><tr><td>Legalpersonidentifier</td><td>Legalpersontype</td><td>Organisationname</td><td>Balance sheettotal</td><td>Firstname</td><td>Lastname</td></tr><tr><td>mandatory</td><td>mandatory</td><td>optional</td><td>optional</td><td>optional</td><td>optional</td></tr><tr><td>{String}</td><td>{Organisation,Natural person}</td><td>{String)</td><td>{lnteger}</td><td>{String}</td><td>{String)</td></tr><tr><td>Apple Inc.</td><td>Organisation</td><td>Apple Inc.</td><td>57,000,000,000</td><td>NULL</td><td>NULL</td></tr><tr><td>GruneErde GoldmanSachs Group,</td><td>Organisation</td><td>Grune Erde</td><td>NULL</td><td>NULL</td><td>NULL</td></tr><tr><td>Inc.</td><td>Organisation</td><td>GoldmanSachs Group,</td><td>12,000,000,000,000</td><td>NULL</td><td>NULL</td></tr><tr><td>Othercompany</td><td>Organisation</td><td>Inc. Othercompany</td><td>NULL</td><td>NULL</td><td>NULL</td></tr><tr><td>Marie Curie</td><td>Naturalperson</td><td>NULL</td><td>NULL</td><td>Marie</td><td>Curie</td></tr><tr><td>AlbertEinstein</td><td>Naturalperson</td><td>NULL</td><td>NULL</td><td>Albert</td><td>Einstein</td></tr><tr><td>Bernhard Riemann</td><td>Natural person</td><td>NULL</td><td>NULL</td><td>Bernhard</td><td>Riemann</td></tr><tr><td>+</td><td>+</td><td></td><td></td><td>**</td><td></td></tr></table></body></html>\n\nFigure 4: Resulting Organisation & Natural person table  \n\nWhich requires the following validation rules to ensure consistency with the data illustrated in Figure 2: Content of the entity type Organisation and Figure 3: Content of the entity type Natural person:  \n\nif Legal person type is Organisation O the following columns must be NULL: First name, Last name O the following columns must not be NULL: Organisation name • if Legal person type is Natural person O the following columns must be NULL: Organisation name, Balance sheet total o the following columns must not be NULL: First name, Last name  \n\nPlease note that without the validation rules we cannot distinguish between NULL values in the column Balance sheet total, i.e., we don’t know if it is NULL because the concept does not apply to the subtype which is the case for Natural person or NULL because the concept is optional for the subtype which is the case for Organisations.  \n\n2.1.2.2. Null Explanatory Values (NEVs) & validation rules As illustrated in the previous example, it is possible to describe necessary validation rules without so called Null Explanatory Values (NEVs), however information, specifically about the optionality of attributes   \n\n\n<html><body><table><tr><td colspan=\"2\"></td><td colspan=\"8\"></td></tr><tr><td>Legal person identifier</td><td>Legal person type mandatory</td><td>Organisation name optional</td><td>Null explanatory value (Organisation name)</td><td>Organisation & Natural person table Balance sheet total optional</td><td>Null explanatory value (Balance sheet total)</td><td>First na me optional</td><td>Null explanatory value (First name)</td><td>Last name</td><td>Null explanatory value (Last name)</td></tr><tr><td rowspan=\"2\">mandatory</td><td rowspan=\"2\"></td><td rowspan=\"2\"></td><td>mandatory</td><td rowspan=\"2\"></td><td>mandatory</td><td rowspan=\"2\"></td><td>mandatory</td><td rowspan=\"2\">optional</td><td rowspan=\"2\">mandatory {Not NULL because mandatory for this type,</td></tr><tr><td>{Not NULL because mandatory for this type,</td><td>(NULL or not NULL because optional for this</td><td>(Not NULL because mandatory for this type,</td><td></td></tr><tr><td rowspan=\"2\">(String)</td><td rowspan=\"2\">(Organisation, Natural person)</td><td rowspan=\"2\">(String)</td><td>NULL because the concept does not apply for this type}</td><td rowspan=\"2\">{(lnteger)</td><td>type, NULL because the concept does not</td><td rowspan=\"2\">(String)</td><td>NULL because the concept does not apply for</td><td rowspan=\"2\">(String)</td><td rowspan=\"2\">NULL because the concept does not apply for</td></tr><tr><td></td><td>apply for this type}</td><td>this type}</td><td>this type}</td></tr><tr><td rowspan=\"2\">Apple Inc.</td><td rowspan=\"2\">Organisation</td><td rowspan=\"2\">Apple Inc.</td><td rowspan=\"2\">Not NULL because mandatory for this type</td><td rowspan=\"2\">57,000,000,000</td><td rowspan=\"2\">NULL or not NULL because optional for this type</td><td rowspan=\"2\">NULL</td><td>NULL because the concept does not apply for</td><td rowspan=\"2\">NULL</td><td>NULL because the concept does not apply for</td></tr><tr><td>this type</td><td>this type</td></tr><tr><td>Grune Erde</td><td>Organisation</td><td>Grune Erde</td><td>Not NULL because mandatory for this type</td><td>NULL</td><td>NULL or not NULL because optional for this type</td><td>NULL</td><td>NULL because the concept does not apply for this type</td><td>NULL</td><td>NULL because the concept does not apply for this type</td></tr><tr><td>Goldman Sachs Group, Inc.</td><td>Organisation</td><td>Goldman Sachs Group, Inc.</td><td>Not NULL because mandatory for this type</td><td>12,000,000,000,000</td><td>NULL or not NULL because optional for this type</td><td>NULL</td><td>NULL because the concept does not apply for this type</td><td>NULL</td><td>NULL because the concept does not apply for this type</td></tr><tr><td>Other company</td><td>Organisation</td><td>Other company</td><td>Not NULL because ma ndatory for this type</td><td>NULL</td><td>NULL or not NULL because optional for this</td><td>NULL</td><td>NULL because the concept does not apply for this type</td><td>NULL</td><td>NULL because the concept does not apply for this type</td></tr><tr><td rowspan=\"2\">Marie Curie</td><td rowspan=\"2\">Natural person</td><td rowspan=\"2\">NULL</td><td>NULL because the concept does not apply for</td><td rowspan=\"2\">NULL</td><td>type NULL because the concept does not apply for</td><td rowspan=\"2\">Marie</td><td rowspan=\"2\">Not NULL because mandatory for this type</td><td rowspan=\"2\">Curie</td><td rowspan=\"2\">Not NULL because mandatory for this type</td></tr><tr><td></td><td>this type</td></tr><tr><td>Albert Einstein</td><td>Natural person</td><td>NULL</td><td>this type NULL because the concept does not apply for this type</td><td>NULL</td><td>NULL because the concept does not apply for</td><td>Albert</td><td>Not NULL because mandatory for this type</td><td>Einstein</td><td>Not NULL because mandatory for this type</td></tr><tr><td>Bernhard Riemann</td><td>Natural person</td><td>NULL</td><td>NULL because the concept does not apply for</td><td>NULL</td><td>this type NULL because the concept does not apply for</td><td>Bernhard</td><td>Not NULL because mandatory for this type</td><td>Riemann</td><td></td></tr><tr><td></td><td></td><td></td><td>this type</td><td></td><td>this type</td><td></td><td></td><td></td><td>Not NULL beca use mandatory for this type</td></tr></table></body></html>  \n\nassociated with certain subtypes is only implicitly comprised in the validation rules and rather difficult to extract, i.e. translating data from the IL to the LDM is not feasible with such an approach. Additional NEVs associated with specific columns would make some of the information more explicit and therefore provide additional context as illustrated in the following figure:  \n\n# Figure 5: Resulting Organisation & Natural person table including Null Explanatory Values (NEVs)  \n\nBecause of the additional information provided in the Null explanatory value (Balance sheet total) we made it explicit that for Organisations it is NULL or not NULL because optional for this type and for Natural persons the value must be NULL because the concept does not apply for this type (see highlighted in green).  \n\n# 2.2 Merging entity types into tables  \n\n# 2.2.1 Merging entity types into a supertype / subtype  \n\n# 2.2.1.1. Description of the forward engineering method  \n\nThis method is used to merge multiple entity types which are connected via subtyping into one of their supertypes. The resulting table comprises the distinct union of all attributes of the merged subtypes as columns, the allowed values of the columns of this table result from the union of allowed values of the attributes. If an attribute is only present in some subtypes but not in others it becomes optional in the resulting table.  \n\n# 2.2.1.2. Legal person example  \n\nTo illustrate the implications of this forward engineering method we will introduce it based on the following example, which was extracted from the LDM and slightly modified to cover additional use cases5.  \n\nOn the logical level, we distinguish between two (sub-)types of Legal persons, i.e. Organisations and Natural persons, as illustrated in the following picture.  \n\n![](/app/media/extracted/images/410bbd7c1565c73b7ba9047d26ec2de77916a87dc1a92d64b6a755e5e83140db.jpg)  \nFigure 6: A Legal person is either an Organisation or a Natural person  \n\nPlease note that this example comprises, among other aspects:  \n\nEnumerated and non-enumerated attributes which are present in some subtypes but not in others,   \noptional and mandatory, e.g. Organisation name, Balance sheet total, Country   \nEnumerated attributes which are present in all subtypes, mandatory in all subtypes, e.g. Institutional sector   \nNon-Enumerated attributes which are present in all subtypes, mandatory in some, optional in others, e.g. Number of employees  \n\nApplying forward engineering methods, specifically Merging entity types into a supertype / subtype, we will end up with one resulting table and additional validation rules.  \n\nFor educational purposes we will explain the required validation rules based on “data”, therefore let’s assume the entity types are populated as following. The content of the entity type Legal person may hold the following data:  \n\n<html><body><table><tr><td colspan=\"2\">Legalperson</td></tr><tr><td>Legalpersonidentifier</td><td>Legalpersontype</td></tr><tr><td>mandatory</td><td>mandatory</td></tr><tr><td>{String}</td><td>{Organisation,Naturalperson}</td></tr><tr><td>Apple Inc.</td><td>Organisation</td></tr><tr><td>GruneErde</td><td>Organisation</td></tr><tr><td>GoldmanSachsGroup,Inc.</td><td>Organisation</td></tr><tr><td>Othercompany</td><td>Organisation</td></tr><tr><td>Marie Curie</td><td>Naturalperson</td></tr><tr><td>AlbertEinstein</td><td>Naturalperson</td></tr><tr><td>BernhardRiemann</td><td>Naturalperson</td></tr><tr><td></td><td></td></tr></table></body></html>  \n\nPlease note that green highlighted columns indicate components of the primary key, in this example it indicates that the value of the column Legal person identifier must be unique. The entity type Organisation may be populated as following:  \n\n<html><body><table><tr><td colspan=\"8\">Organisation</td></tr><tr><td>Legalpersonidentifier</td><td>Organisation name</td><td>Legal entityidentifier (LEl)</td><td>Institutionalsector</td><td>Number ofemployees</td><td>Legal form</td><td>Country</td><td>Balance sheet total</td></tr><tr><td>mandatory</td><td>mandatory</td><td>mandatory</td><td>mandatory</td><td>mandatory</td><td>mandatory</td><td>mandatory</td><td>optional</td></tr><tr><td>{String)</td><td>(String)</td><td>{String}</td><td>{lnstitutional sectors applicable to Companies}</td><td>{lnteger)</td><td>{Legal form codes including Not applicable)</td><td>{ISOCountriesincludingNotapplicable)</td><td>{lnteger)</td></tr><tr><td>Apple Inc.</td><td>Apple Inc.</td><td>Apple LEI</td><td>Non-financial corporations</td><td>147000</td><td>Stock company</td><td>United States ofAmerica</td><td>57,000,000,000</td></tr><tr><td>Grune Erde</td><td>Grune Erde</td><td>Grune Erde LEI</td><td>Non-financial corporations</td><td>500</td><td>Limited</td><td>Austria</td><td>NULL</td></tr><tr><td>Goldman Sachs Group, Inc.</td><td>Goldman Sachs Group, Inc.</td><td>Goldman Sachs LEI</td><td>Creditinstitution</td><td>40500</td><td>Stock company</td><td>United StatesofAmerica</td><td>12,000,000,000,000</td></tr><tr><td>Other company</td><td>Other company</td><td>Other company LEl</td><td>Non-financialcorporations</td><td></td><td>Limited</td><td>Not applicable</td><td>NULL</td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></table></body></html>\n\nFigure 8: Content of the entity type Organisation  \n\n# And, the entity type Natural person may have the following content:  \n\nFigure 9: Content of the entity type Natural person   \n\n\n<html><body><table><tr><td colspan=\"9\">Naturalperson</td></tr><tr><td>Legalpersonidentifier</td><td>Firstname</td><td>Lastname</td><td>Gender</td><td>Institutionalsector</td><td>Country</td><td>Nationality</td><td>Socialsecuritynumber</td><td>Numberofemployees</td></tr><tr><td>mandatory</td><td>mandatory</td><td>mandatory</td><td>mandatory</td><td>mandatory</td><td>mandatory</td><td>mandatory</td><td>optional</td><td>optional</td></tr><tr><td>{String}</td><td>{String)</td><td>{String)</td><td>{Gender}</td><td>{lnstitutionalsectorsapplicabletoNatural persons}</td><td>{ISOCountries}</td><td>{ISOCountries}</td><td>{String}</td><td>{lnteger}</td></tr><tr><td>Marie Curie</td><td>Marie</td><td>Curie</td><td>Female</td><td>Households</td><td>France</td><td>Polish</td><td>NULL</td><td>2</td></tr><tr><td>AlbertEinstein</td><td>Albert</td><td>Einstein</td><td>Male</td><td>Households</td><td>UnitedStatesofAmerica</td><td>German</td><td>ssnAlbertEinstein</td><td>NULL</td></tr><tr><td>BernhardRiemann</td><td>Bernhard</td><td>Riemann</td><td>Male</td><td>Households</td><td>Germany</td><td>German</td><td>NULL</td><td>NULL</td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></table></body></html>  \n\nWrapping up these entity types will result in one table comprising all the columns illustrated in figures above, we may illustrate it as following:  \n\nFigure 10: Legal person table   \n\n\n<html><body><table><tr><td colspan=\"3\">Legal person Table</td></tr><tr><td></td><td>Legalpersonidentifier</td><td>String</td></tr><tr><td></td><td>Legalperson type</td><td>Legalperson type</td></tr><tr><td></td><td>Institutionalsector</td><td>InstitutionalsectorapplicabletoOrganisationsorNaturalpersons</td></tr><tr><td></td><td>Legal form</td><td>Legalform codeincludingNotapplicable</td></tr><tr><td></td><td>Country</td><td>Legal formcodeincludingNotapplicable</td></tr><tr><td></td><td>Gender</td><td>GenderincludingNotapplicable</td></tr><tr><td></td><td>Nationality</td><td>ISOCountriesincludingNotapplicable</td></tr><tr><td></td><td>Organisation name</td><td>String</td></tr><tr><td></td><td>Legalentityidentifier(LEl)</td><td>String</td></tr><tr><td></td><td>Numberofemployees</td><td>Integer</td></tr><tr><td></td><td>Balancesheettotal</td><td>Integer</td></tr><tr><td></td><td>Firstname</td><td>String</td></tr><tr><td></td><td>Lastname</td><td>String</td></tr><tr><td></td><td>Socialsecuritynumber</td><td>String</td></tr><tr><td colspan=\"3\">LegalpersonTablePK(Legalpersonidentifier)</td></tr></table></body></html>  \n\n# The associated data compatible with the data illustrated in Figure 7: Content of the entity type Legal person to Figure 9: Content of the entity type Natural person is as following:  \n\nFigure 11: Content of the Legal person table   \n\n\n<html><body><table><tr><td>Legal person identifier</td><td>Legal person type</td><td>Organisation name</td><td>Legal entityidentifier (LEI)</td><td>Institutional sector</td><td>Number of employees</td><td>Legal form</td><td>Country</td><td>Balance sheet total</td><td>First name</td><td>Last name</td><td>Gender</td><td>Nationality</td><td>Social security number</td></tr><tr><td>mandatory</td><td>mandatory</td><td>optional</td><td>optional</td><td>mandatory {lnstitutional sectors</td><td>optional</td><td>mandatory</td><td>mandatory</td><td>optional</td><td>optional</td><td>optional</td><td>mandatory</td><td>mandatory</td><td>optional</td></tr><tr><td>{String}</td><td>(Organisation, Natural person}</td><td>{String}</td><td>{String}</td><td>applicable to Companies or Natural</td><td>{lnteger}</td><td>{Legal form codes including Not applicable}</td><td>{ISO Countries including Not applicable}</td><td>{lnteger}</td><td>{String}</td><td>{String)</td><td>{Gender including Not applicable}</td><td>{ISO Countries including Not applicable}</td><td>{String}</td></tr><tr><td>Apple Inc.</td><td>Organisation</td><td>Apple Inc.</td><td>Apple LEI</td><td>persons} Non-financial corporations</td><td>147000</td><td>Stockcompany</td><td>United States of America</td><td>57,000,000,000</td><td>NULL</td><td>NULL</td><td>Not applicable</td><td>Notapplicable</td><td>NULL</td></tr><tr><td>Grune Erde</td><td>Organisation</td><td>Grune Erde</td><td>Grune Erde LEI</td><td>Non-financial corporations</td><td>500</td><td>Limited</td><td>Austria</td><td>NULL</td><td>NULL</td><td>NULL</td><td>Notapplicable</td><td>Notapplicable</td><td>NULL</td></tr><tr><td>Goldman Sachs Group,Inc.</td><td>Organisation</td><td>Goldman Sachs Group,Inc.</td><td>Goldman Sachs LEI</td><td>Creditinstitution</td><td>40500</td><td>Stock company</td><td>United States of America</td><td>12,000,000,000,000</td><td>NULL</td><td>NULL</td><td>Not applicable</td><td>Not applicable</td><td>NULL</td></tr><tr><td>Other company</td><td>Organisation</td><td>Other company</td><td>Other company LEI</td><td>Non-financial corporations</td><td>3</td><td>Limited</td><td>Not applicable</td><td>NULL</td><td>NULL</td><td>NULL</td><td>Notapplicable</td><td>Not applicable</td><td>NULL</td></tr><tr><td>Marie Curie</td><td>Natural person</td><td>NULL</td><td>NULL</td><td>Households</td><td>2</td><td>Not applicable</td><td>France</td><td>NULL</td><td>Marie</td><td>Curie</td><td>Female</td><td>Polish</td><td>NULL</td></tr><tr><td>Albert Einstein</td><td>Natural person</td><td>NULL</td><td>NULL</td><td>Households</td><td>NULL</td><td>Not applicable</td><td>United States of America</td><td>NULL</td><td>Albert</td><td>Einstein</td><td>Male</td><td>German</td><td>ssnAlbertEinstein</td></tr><tr><td>Bernhard Riemann</td><td>Natural person</td><td>NULL</td><td>NULL</td><td>Households</td><td>NULL</td><td>Not applicable</td><td>Germany</td><td>NULL</td><td>Bernhard</td><td>Riemann</td><td>Male</td><td>German</td><td>NULL</td></tr><tr><td></td><td></td><td>\"*</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td>\"*</td><td></td><td></td><td></td></tr></table></body></html>\n\nPlease note that default values are illustrated in red, e.g. the value NULL in the column Organisation name for Marie Curie. The associated validation rules may be formulated as following:  \n\nIf the Legal person type is Organisation  \n\no The following columns must be NULL: First name, Last name, Social security number   \no The following columns must not be NULL: Organisation name, Legal entity identifier (LEI), Number of employees   \no The following columns must take the value Not applicable: Gender, Nationality   \nO The following columns must take specific values: The column Institutional sector must take a value from {Institutional sectors applicable to Companies}  \n\nIf the Legal person type is Natural person  \n\nThe following columns must be NULL: Organisation name, Legal entity identifier (LEI), Balance sheet total The following columns must not be NULL: First name, Last name o The following columns must take the value Not applicable: Legal form The following columns must take specific values: The column Institutional sector must take a value from {Institutional sectors applicable to Natural persons}  \n\nThe column Country must take a value from {ISO Countries} The column Gender must take a value from {Gender} The column Nationality must take a value from {ISO Countries}  \n\nWe would like to highlight that we are not able to distinguish between NULL because an attribute was optional for a specific subtype and NULL because the attribute does not apply for a specific subtype. For example, we are not able to distinguish between the NULL values for the column Balance sheet total for the records of Organisation Grüne Erde or Marie Curie, where the latter is NULL because the concept (of Balance sheet total) does not apply for a specific subtype (i.e. for Natural persons) and the former is NULL because the concept is optional for a specific subtype. In theory this information may be extracted from the validation rule stating that the Column Balance sheet total must be NULL for Natural persons, however this requires the creation of logic from statements which is a rather difficult task and consequently not recommended.  \n\n# 2.2.1.3. Subtypes, merging & Relationships  \n\nSubtypes may be connected to other entity types via relationship types. When a subtype is merged into its supertype these relationship types need to be managed as well, otherwise we would lose them and therefore our forward engineered model would be incomplete. An example of such a relationship type is the relationship type between an Organisation and its Organisational units, i.e. an Organisation has zero, one-or-many Organisational units. In more practical terms, a Credit institution may have multiple Branches. The situation, as described in the LDM, is illustrated in the following figure.  \n\n![](/app/media/extracted/images/bb840050b629eefbd89ae92c5b63651e9b4cb19a1f6760f21fed17eaf18e06c3.jpg)  \nFigure 12: Relationship type between Institutional unit of foreign branches and Organisational unit and their hierarchy  \n\nWhen merging the involved entity types into their respective supertypes, relationship types applicable only to subtypes vanish because they cannot be expressed via SQL foreign key constraints6 anymore. Consequently, they cannot be established on the database level directly but have to be validated via validation rules. The following figure illustrates the resulting situation:  \n\n![](/app/media/extracted/images/592feb3d1585e8e6f00ca42013f62dca456120bf302d8740f6781f399cf8d941.jpg)  \nFigure 13: Party & Group table  \n\nThe following validation rules complete the picture, i.e., ensure that the columns establishing the connection between the tables can only be populated according to the description in the LDM:  \n\nAs regards the Party table  \n\no The Institutional unit of foreign branches Group identifier must be NULL for all Parties where the Organisational unit type is different to Branch   \no If the Institutional unit of foreign branches Group identifier is not NULL, the following conditions must hold: The Organisational unit type must be Branch The Institutional unit of foreign branches Group identifier must refer to a Group where the Internal group type is Institutional unit of foreign branches  \n\nDisjoint subtyping describes a situation where a supertype is split into two different disjoint classifications. In the LDM this is the case for Securities in the form of debt or direct ownership, where one type of subtyping is by classification into Debt security, Equity security and Fund security while the other type of subtyping is by type of identifier into ISIN securities and Non-ISIN securities.  \n\n![](/app/media/extracted/images/4b5ea4c7275a1edbed6b1c79f332eb5e2784c54884dc634c2235e1e334ace55e.jpg)  \nFigure 14: Disjoint subtyping of Security (in the form of debt or direct ownership) by product (Debt security and Equity or Fund security) and identifier (ISIN vs. Non-ISIN)  \n\nAs regards necessary validation rules to ensure consistency with the LDM the only real difference is that each type of subtyping will result in a separate set of validation rules. In our specific example mentioned above this would result in validation rules for subtyping by classification and validation rules for subtyping by type of identifier. Other than that, the resulting validation rules are similar to the validation rules described in the previous section, see Legal person example.  \n\n# 2.2.1.5. Implications  \n\nAs discussed in the previous sections the application of this forward engineering method has implications if consistency with the LDM must be ensured.  \n\nAs regards the columns of the resulting table with respect to the attributes they originate from:  \n\n• For non-enumerated columns it needs to be ensured that NULL values are allowed / not allowed according to the specification in the originating entity type, e.g., if a non-enumerated attribute is mandatorily present for a specific subtype, the corresponding column must be different than NULL For enumerated columns it needs to be ensured that the value is Not applicable by default according to the specification in the merged entity types, e.g., if an enumerated attribute is not present in all subtypes that are to-be-merged, the resulting column must take the value Not applicable for those subtypes   \nFor enumerated columns it needs to be ensured that the allowed values correspond to the specification in the LDM with respect to the specific subtypes, e.g., if a mandatory, enumerated attribute allowed only ISO country codes the corresponding column must only allow these values for the specific subtype as well   \n• For columns establishing a connection with other tables resulting from relationship types of subtypes, it needs to be ensured that the allowed value refers to the allowed subtypes only  \n\nAnother implication of merging entity types with different attributes is that the resulting table will comprise mainly optional columns (or columns where the value Not applicable is valid).  \n\n# 2.2.2 Merging entity types connected via relationship types  \n\nMerging entity types connected via relationship types is a forward engineering method where two entity types that are connected via a relationship type are merged into one table. This method is intended for identifying relationship types only. The cardinality of the relationship type may be of type one-to-one or oneto-many which are either optional or mandatory. The resulting table’s primary key will be equal to the largest primary key of the involved entity types, e.g., if a one-to-many relationship type is involved the resulting table’s primary key will be equal to the entity type with the many cardinality.  \n\n# 2.2.2.2. Merging one-to-one, mandatory entity types  \n\nSince one-to-one, mandatory relationship types represent an arbitrary split of an entity type into two entity types, at least from a logical perspective, the resulting table’s columns will be the result of the union of all attributes of the involved entity types. The optionality of the columns doesn’t change.  \n\nIn the LDM such a one-to-one relationship type is established via Party and Party derived data where the later entity type comprises derived data, e.g., the Institutional sector according to EBA ITS. The LDM situation may be illustrated as following:  \n\n![](/app/media/extracted/images/821319f881b3fc92e45dfffd00134d9f38316d93d266d680bad0a30a00f776b3.jpg)  \n2.2.2.1. Description of the forward engineering method   \nFigure 15: Party & Party derived data  \n\nWhile the resulting table may be illustrated like this:  \n\n![](/app/media/extracted/images/1a5e6a90cddc14fff98728a57b31090facd5973164bfa7cce830954464583150.jpg)  \n2.2.2.3. Merging one-to-one, optional entity types (“de-facto subtypes”)  \n\nWhen merging de-facto subtypes, all attributes of the optional entity type become optional. Because of the lack of discriminators for de-facto subtypes in the LDM it is not possible to distinguish between optional and mandatory columns in the resulting Table directly. Consequently, validating data of the IL can only be achieved indirectly, i.e., if one of the columns resulting from a mandatory attribute is different to NULL / Not applicable all other columns resulting from mandatory attributes must be different to NULL / Not applicable.  \n\n# 2.2.2.4. Merging one-to-many, mandatory  \n\nMerging entity types which are connected via a one-to-many, mandatory relationship type creates a table having the primary key of the entity type, which is at the many end of the relationship type, i.e., the one with more attributes contributing to the primary key. Merging such entity types requires validation rules to ensure that duplicated values are consistent. As an example, we look at the situation of Protection items and their Protection values in the LDM.  \n\n![](/app/media/extracted/images/c38fcc613a2b1358546f5f0280eb1c6cd13a0343b427727ba8118a0b91693a2e.jpg)  \nFigure 17: Protection item has one-or-many Protection value(s)  \n\nA Protection item has one-or-many Protection values, while a Protection value always belongs to a Protection item. The resulting table after merging these entities looks as following:  \n\n<html><body><table><tr><td colspan=\"2\">Protectionitem&ProtectionvalueTable</td></tr><tr><td>Protectionitemidentifier</td><td>String</td></tr><tr><td>Typeofprotectionvalue</td><td>Typeofprotectionvalue</td></tr><tr><td>Protectionitemtype</td><td>Protectionitem type</td></tr><tr><td>Originalprotectionvalue</td><td>Integer</td></tr><tr><td>Dateoforiginalprotectionvalue</td><td>Date</td></tr><tr><td>Protectionvalue</td><td>Integer</td></tr><tr><td>Protectionvaluedate</td><td>Date</td></tr><tr><td colspan=\"2\">Protectionitem&ProtectionvalueTablePK（Typeofprotectionvalue，Protectionitemidentifier)</td></tr><tr><td colspan=\"2\">AProtection item is an item thatmaybe used asa protection(inaProtection arrangement),e.g Financialguarantee(received)oraRealestateprotection.</td></tr></table></body></html>  \n\nWe also need to ensure that the same Protection item always has equal values in the attributes present in the entity type Protection item, otherwise referential integrity would be violated, therefore:  \n\n• For each value of the attribute Protection item identifier the values of the following attributes need to take the same value: Protection item type, Original protection value, Date of original protection value  \n\n2.2.2.5. Merging one-to-many, optional  \n\nThe situation for entity types connected via a one-to-many, optional relationship type is a little different than the previous situation. The main reason is that with such a relationship type the entity type at the many end of the relationship type is optional. Therefore, when merging such entity types, we need to ensure that the primary key (constraint) is not violated.  \n\nFor educational purposes we quote the definition of the primary key according to w3schools: “The primary key constraint uniquely identifies each record in a table. Primary keys must contain unique values, and cannot contain NULL values.” 7 The important aspect that we need to consider in this context is that the values (of the primary key) must not be NULL.  \n\n2.2.2.5.1. Entity types on the many side of the relationship with non-enumerated attributes being components of the primary key  \n\nClearly, if we merge two entity types which are related via a one-to-many, optional relationship type, where the primary key of the entity type on the many side of the relationship type comprises non-enumerated attributes which are not present in the other entity type we will violate this definition and therefore the resulting table will not be a valid table in a relational data model. To illustrate the content of the previous paragraph please consider the following situation:  \n\n![](/app/media/extracted/images/3063bbe076fa0c7ab879c0741053a238a42d5753a1c00dbb0be01167d4ad3628.jpg)  \nFigure 19: Debt security is involved in zero, one-or-many Debt security position(s)  \n\nA Debt security may be held by multiple Investors while an Investor may invest in multiple Debt securities. We call this combination of a Debt security and an Investor a Debt security position. Please note that not every Debt security is involved in a Debt security position, i.e., the relationship type between Debt security and Debt security position is optional. To illustrate the problem, let’s consider the following example: in the entity type Debt security we register the following security information:  \n\n<html><body><table><tr><td colspan=\"3\">Debtsecurity</td></tr><tr><td>Securityidentifier</td><td>Currency</td><td></td></tr><tr><td>{String}</td><td>{Euro,UnitedStatesDollar.,..}</td><td></td></tr><tr><td>Austrianbond</td><td>Euro</td><td></td></tr><tr><td>Germanbond</td><td>Euro</td><td></td></tr><tr><td>Companybond</td><td>UnitedStatesDollar</td><td></td></tr><tr><td></td><td></td><td></td></tr></table></body></html>  \n\nWhile the Austrian and the German bond are held by Parties, the Company bond is not, therefore the content of the entity type Debt security position might be illustrated as following:  \n\nFigure 20: Registered debt securities   \n\n\n<html><body><table><tr><td colspan=\"3\">Debtsecurityposition</td></tr><tr><td>Securityidentifier</td><td>InvestorPartyidentifier</td><td>Outstanding nominal amount</td></tr><tr><td>{String}</td><td>{String}</td><td>{lnteger}</td></tr><tr><td>AustrianBond</td><td>SomeAustrianbank</td><td>13</td></tr><tr><td>AustrianBond</td><td>SomeGermanbank</td><td>19</td></tr><tr><td>GermanBond</td><td>SomeItalianbank</td><td>23</td></tr><tr><td></td><td></td><td></td></tr></table></body></html>\n\nFigure 21: Content of the entity type Debt security position  \n\nIf we’d merge the two entity types the resulting table’s primary key would be equal to the primary key of the Debt security position entity type. The resulting data for this example would look as following:  \n\n<html><body><table><tr><td colspan=\"4\">Debtsecurity&DebtsecuritypositionTable</td></tr><tr><td>Securityidentifier</td><td>InvestorPartyidentifier</td><td>Currency</td><td>Outstandingnominal amount</td></tr><tr><td>{String}</td><td>{String}</td><td>{Euro,UnitedStates Dollar,..}</td><td>{lnteger}</td></tr><tr><td>AustrianBond</td><td>SomeAustrianbank</td><td>Euro</td><td>13</td></tr><tr><td>AustrianBond</td><td>SomeGermanbank</td><td>Euro</td><td>19</td></tr><tr><td>GermanBond</td><td>SomeItalianbank</td><td>Euro</td><td>23</td></tr><tr><td>Companybond</td><td>NULL</td><td>UnitedStatesDollar</td><td>NULL</td></tr><tr><td></td><td></td><td></td><td></td></tr></table></body></html>\n\nFigure 22: Content of the Debt security & Debt security position table  \n\nSince the Company bond is not held by any Investor, the Attribute Investor Party identifier would be NULL (highlighted in red). This, however, would violate the definition of the primary key and therefore merging entity types connected via a one-to-many, optional relationship type in case the entity type on the many side of the relationship type has a non-enumerated attribute, that is not part of the other entity type’s primary key, as a component of the primary key is not possible.  \n\nTo ensure that duplicated values are consistent we also need to implement additional validation rules, e.g., to ensure that the same value of the attribute Security identifier has the same value in the attribute Currency.  \n\n2.2.2.5.2. Entity types on the many side of the relationship type with enumerated attributes being components of the primary key  \n\nThe situation is slightly different if the attributes contributing to the primary key of the entity type (on the many side of the relationship type), that are not comprised in the other entity type’s primary key, are enumerated. In this case someone might argue that the value Not applicable is different to NULL and therefore a valid value for absent data. Consequently, following this argumentation, we would not violate the definition of the primary key. Please note that this argument is debatable because indeed the value Not applicable has the same meaning as NULL for non-enumerated attributes.  \n\nThis constellation occurs in multiple locations in the LDM, for example when applying the role concept to specific entity types. To illustrate the indicated situation and the implications of the application of this forward engineering method in more detail let’s look at the role concept applied to Parties.  \n\n![](/app/media/extracted/images/0bd85183d2e2b86127249923a48706b8c445d1a0b367ff5252ea911d50fed5fb.jpg)  \nFigure 23: A Party acts in zero, one-or-many Party role(s)   \nFigure 24: Content of the entity type Party  \n\nVia this optional, one-to-many relationship type between Party and Party role a Party can act in multiple Party roles, e.g. Debtor, Creditor, Investor, at the same time. Like the previous example we will analyse some “data”, e.g.  \n\n<html><body><table><tr><td colspan=\"3\">Party</td></tr><tr><td>Partyidentifier</td><td>Country</td><td></td></tr><tr><td>{String}</td><td>{Austria, Germany, ..</td><td></td></tr><tr><td>Austrianbank</td><td>Austria</td><td></td></tr><tr><td>Germanbank</td><td>Germany</td><td></td></tr><tr><td>SomeCompany</td><td>Austria</td><td></td></tr><tr><td></td><td></td><td></td></tr></table></body></html>  \n\nSome of these Parties may act in specific roles, e.g., the Austrian bank may act in the Party roles Creditor and Investor, the German bank may act in the Party role Investor. Please note that Some Company does not act in any Party role.  \n\n<html><body><table><tr><td colspan=\"2\">Partyrole</td></tr><tr><td>Partyidentifier</td><td>Partyroletype</td></tr><tr><td>{String}</td><td>{Debtor, Creditor,</td></tr><tr><td>Austrianbank</td><td>Creditor</td></tr><tr><td>Austrianbank</td><td>Investor</td></tr><tr><td>Germanbank</td><td>Investor</td></tr><tr><td></td><td></td></tr></table></body></html>  \n\nIf we would merge these two entity types, the resulting table’s primary key is equal to the primary key of the entity type Party role. For the resulting table, the data indicated in Figure 24: Content of the entity type Party and Figure 25: Content of the entity type Party role would look as following:  \n\nFigure 26: Resulting Party & Party role table   \n\n\n<html><body><table><tr><td colspan=\"4\">Party&PartyroleTable</td></tr><tr><td>Partyidentifier</td><td>Partyroletype</td><td>Country</td><td></td></tr><tr><td>{String}</td><td>{Debtor,Creditor, Investor.,..}</td><td>{Austria, Germany...}</td><td></td></tr><tr><td>Austrianbank</td><td>Creditor</td><td>Austria</td><td></td></tr><tr><td>Austrianbank</td><td>Investor</td><td>Austria</td><td></td></tr><tr><td>Germanbank</td><td>Investor</td><td>Germany</td><td></td></tr><tr><td>SomeCompany</td><td>Notapplicable</td><td>Austria</td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr></table></body></html>  \n\nBecause Some Company does not act in any Party role, we would use the value Not applicable as a default value.  \n\nAs regards validation rules, similar to the previous example we will need to ensure that every value of Party identifier has consistent values for columns arising solely form the entity type Party, i.e. ensure consistency of duplicated values.  \n\n# 2.2.2.6. Implications  \n\nThe main restriction when applying this forward engineering method is that entity types which are connected via one-to-many, optional relationship types, where the entity type on the many side of the relationship type has non-enumerated attributes (which are not present in the other entity type) as components of the primary key, cannot be merged. In case of enumerated attributes contributing to the primary key we may apply this forward engineering method, however the difference between NULL and Not applicable is debateable.  \n\nAnother important remark from the previous sections is that the resulting tables from entity types connected via one-to-one, optional relationship types (“de-facto subtypes”) can only be validated indirectly against the LDM.  \n\nLastly, when applying this method to the entity types connected via one-to-many relationship types we need to specify validation rules to ensure that duplicated values are consistent according to their original primary keys.  \n\n# 2.2.3 Merging tables with equal surrogate keys  \n\n# 2.2.3.1. Description of the forward engineering method  \n\nIn some situations, we may want to merge entity types having different primary keys. Because of the different primary keys we cannot simply merge these entity types as described in section Merging entity types into a supertype / subtype but we would have to create a matching primary key first. We refer to this operation as the Creation of surrogate keys. It goes without saying that we need additional validation rules to ensure referential integrity if we create such a new surrogate key. After different entity types have the same surrogate key we may want to merge them similar to the situation described in Merging entity types into a supertype / subtype.  \n\n# 2.2.3.2. Creation of surrogate keys  \n\nIn practical terms, the creation of a surrogate key for an entity type involves the following steps:  \n\n? Definition of a new surrogate key, i.e. adding an attribute / column with unique values Removing the previous primary key (in terms of key constraints)   \n? Specifying the new surrogate key to be the primary key Specifying validation rules ensuring consistency as regards the previous primary key  \n\nAfter creating surrogate keys for different entity types, we may merge these entity types. One prerequisite for merging entity types having the same surrogate key is that the values of the surrogate keys of the entities do not overlap. If these values would overlap, we cannot distinguish between the instances anymore. The required validation rules for this method are similar to the validation rules described in the Legal person example.  \n\n# 2.2.3.4. Implications  \n\nThe main constraint when applying this forward engineering method is to ensure that the surrogate keys of the different entity types to-be-merged must have non-overlapping values. However, this is a data related topic which can only described from a meta data perspective like the BIRD documentation.  \n\nAnother consideration in this context that should be taken into account is the data lineage capabilities between the LDM and the IL, i.e. how “easy” it is to link the entity types of the LDM to the table of the IL or vice-versa. Applying this forward engineering method on too many entity types of the LDM to merge them into one table of the IL will make it more difficult to understand how the tables are related (in detail) with the entity types.  "
}